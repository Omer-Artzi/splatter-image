# -*- coding: utf-8 -*-
"""gaussian_renderer/__init__.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1U-Wi1_iebf8rueqdxSDvU--Xygu-OHGh
"""

"""
Explanation of Changes:
Separate Front and Back Layers:

The pc dictionary has been split into pc_front and pc_back to manage the two layers.
Rendering Process for Each Layer:

The rasterizer is called twice, once for the front (pc_front) and once for the back (pc_back).
Combining the Rendered Layers:

A simple combination (average) of the two layers is done, but you can modify the combination logic as needed.
Returning Combined Output:

The combined output is returned, including the final rendered image and other relevant parameters.
"""

import math
import torch
import numpy as np

from diff_gaussian_rasterization import GaussianRasterizationSettings, GaussianRasterizer
from utils.graphics_utils import focal2fov

def render_predicted(pc_front: dict,
                     pc_back: dict,
                     world_view_transform,
                     full_proj_transform,
                     camera_center,
                     bg_color: torch.Tensor,
                     cfg,
                     scaling_modifier=1.0,
                     override_color=None,
                     focals_pixels=None):
    """
    Render the scene as specified by two layers: pc_front (for the front) and pc_back (for the back).
    Background tensor (bg_color) must be on GPU!
    """

    screenspace_points = torch.zeros_like(pc_front["xyz"], dtype=pc_front["xyz"].dtype, requires_grad=True, device=pc_front["xyz"].device) + 0
    try:
        screenspace_points.retain_grad()
    except:
        pass

    if focals_pixels is None:
        tanfovx = math.tan(cfg.data.fov * np.pi / 360)
        tanfovy = math.tan(cfg.data.fov * np.pi / 360)
    else:
        tanfovx = math.tan(0.5 * focal2fov(focals_pixels[0].item(), cfg.data.training_resolution))
        tanfovy = math.tan(0.5 * focal2fov(focals_pixels[1].item(), cfg.data.training_resolution))

    raster_settings = GaussianRasterizationSettings(
        image_height=int(cfg.data.training_resolution),
        image_width=int(cfg.data.training_resolution),
        tanfovx=tanfovx,
        tanfovy=tanfovy,
        bg=bg_color,
        scale_modifier=scaling_modifier,
        viewmatrix=world_view_transform,
        projmatrix=full_proj_transform,
        sh_degree=cfg.model.max_sh_degree,
        campos=camera_center,
        prefiltered=False,
        debug=False
    )

    rasterizer = GaussianRasterizer(raster_settings=raster_settings)

    # Front layer
    rendered_image_front, radii_front = rasterizer(
        means3D=pc_front["xyz"],
        means2D=screenspace_points,
        shs=torch.cat([pc_front["features_dc"], pc_front["features_rest"]], dim=1) if "features_rest" in pc_front else pc_front["features_dc"],
        colors_precomp=override_color,
        opacities=pc_front["opacity"],
        scales=pc_front["scaling"],
        rotations=pc_front["rotation"],
        cov3D_precomp=None)

    # Back layer
    rendered_image_back, radii_back = rasterizer(
        means3D=pc_back["xyz"],
        means2D=screenspace_points,
        shs=torch.cat([pc_back["features_dc"], pc_back["features_rest"]], dim=1) if "features_rest" in pc_back else pc_back["features_dc"],
        colors_precomp=override_color,
        opacities=pc_back["opacity"],
        scales=pc_back["scaling"],
        rotations=pc_back["rotation"],
        cov3D_precomp=None)

    # Combine front and back layers (e.g., simple average)
    combined_image = (rendered_image_front + rendered_image_back) / 2

    # Return the combined image and relevant data
    return {
        "render": combined_image,
        "viewspace_points": screenspace_points,
        "visibility_filter": (radii_front > 0) | (radii_back > 0),
        "radii": (radii_front + radii_back) / 2
    }